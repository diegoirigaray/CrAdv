import os
import json
import copy
import matplotlib
matplotlib.use('agg')
from matplotlib import pyplot as plt


class Writer(object):
    '''
    Class responsible for writing the tasks results in the results files.
    '''
    def __init__(self, base_path):
        self.base_path = base_path

    def _get_base_path(self, net, task, defense=None, attack=None):
        '''
        Returns the results path for a given configuration.

        Given the model, task, defense and attack instances, creates the folder
        on where the results file should be stored and returns its path.
        '''
        defense_id = ("_{}".format(defense.data["defense_name"]) if defense and
                      hasattr(defense, 'data') else "")
        attack_id = ("_{}".format(attack.data["attack_name"]) if attack and
                     hasattr(attack, 'data') else "")

        path = "{}/{}/{}{}{}".format(
            self.base_path,
            net.data["net_id"],
            task.data["task_name"],
            defense_id,
            attack_id)
        if not os.path.exists(path):
            os.makedirs(path)
        return path

    def get_task_path(self, net, task, defense=None, attack=None):
        '''
        Returns the path on where tasks may save extra data.

        Given the model, task, defense and attack instances, creates a folder
        next to where the results file will be saved (with it's same name) and returns
        its path. This path may be used by tasks to store non serializable data.
        '''
        base_path = self._get_base_path(net, task, defense, attack)

        index = 1
        while os.path.exists("{}/result_{}.json".format(base_path, index)):
            index += 1
        path = "{}/result_{}".format(base_path, index)
        if not os.path.exists(path):
            os.makedirs(path)
        return path

    def save_results(self, task, net, defense, attack, result, time):
        '''
        Creates and saves the results file.

        Given the model, task, defense and attack instances, and the actual result
        object, creates and saves the results file in the appropriate folder.
        In addition to the actual result, saves the parameters passed to each component.
        '''
        # Gets the result's path
        path = self._get_base_path(net, task, defense, attack)

        # Gets the result's file index
        index = 1
        while os.path.exists("{}/result_{}.json".format(path, index)):
            index += 1

        # If the directory generated by `get_task_path` is empty, erase it
        task_p = self.get_task_path(net, task, defense, attack)
        if os.path.exists(task_p) and os.path.isdir(task_p) and not os.listdir(task_p):
            os.rmdir(task_p)

        # If the result is an exception catched by the scheduler
        if isinstance(result, Exception):
            with open('{}/result_{}.json'.format(path,index), 'w') as outfile:
                json.dump(str(result), outfile, indent=4)
            return

        # Ensembles the result object with the execution data
        a_data = None
        if attack and hasattr(attack, 'data'):
            a_data = copy.deepcopy(attack.data)
            a_data.pop('specific_models', None)
            # If the attack is using an specific model, specify it in the attack data
            if 'net_id' in attack.model.data and attack.model.data['net_id'] != net.data['net_id']:
                a_data['specific_model'] = attack.model.data
        d_data = defense.data if defense and hasattr(defense, 'data') else None
        result_obj = {
            'task_data': task.data,
            'net_data': net.data,
            'attack_data': a_data,
            'defense_data':d_data,
            'exec_time': time,
            'result': result
        }

        # Saves the results file
        with open('{}/result_{}.json'.format(path,index), 'w') as outfile:
            json.dump(result_obj, outfile, indent=4)

        # If plotting keys are specified and list of results
        if task.data['plot_keys'] and 'results' in result and 'variable_name' in result:
            # Gets the x and y values
            variable_name = result.get('variable_name')
            data = result.get('results').items()
            x_values = [float(x[0]) for x in data]
            y_values = [x[1] for x in data]

            # Plot each of the specified properties
            for k, key in enumerate(task.data['plot_keys']):
                plt.xlabel(variable_name)
                plt.ylabel(task.data['task_name'])
                plt.plot(x_values, [float(y[key]) for y in y_values], label=key)

                # If shouldnt plot together, closes the plot
                if not task.data['plot_together']:
                    plt.legend()
                    plt.savefig('{}/result_{}_plot{}.png'.format(path, index, k))
                    plt.close()

            if task.data['plot_together']:
                plt.legend()
                plt.savefig('{}/result_{}_plot.png'.format(path, index))
                plt.close()
